/**
 * Dynamic header generation and event bindings for header actions.
 */

if (!window.dashboard) {
  window.dashboard = {};
}

/**
 * @param scriptData{{
 *   title: string,
 *   finishLink: string,
 *   statsPath: string,
 *   showStageLinks: boolean,
 *   trophies: Object,
 *   scriptId: number,
 *   scriptLevelId: number,
 *   currentLevelIndex: number,
 *   levels: Array.<{
 *     displayText: string,
 *     status: string,
 *     unplugged: boolean,
 *     assessment: boolean
 *   }>
 * }}
 */
dashboard.buildHeader = function () {
  // TODO: Global, until we create a component cache
  window.headerProgress = new HeaderProgress( $('.navbar-header') );
};


// TODO: Enable the 'destroyed' method?
// (function($){ $.event.special.destroyed = { remove: function(o) { if (o.handler) { o.handler() } } } })(jQuery);

// New private scope -- a lot of this is boilerplate for class structures, taken from coffeescript
(function() {
  var
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  // class UIComponent: this is a lightweight inheritable class modeled after React
  UIComponent = (function() {

    function UIComponent($el) {
      this.onClick = __bind(this.onClick, this);
      this.onUpdate = __bind(this.onUpdate, this);
      this.onDestroy = __bind(this.onDestroy, this);

      // Set the initial state
      this.state = this.getInitialState() || {};

      this.componentWillMount();

      this.$el = $el;
      this.$el.on('click', this.onClick);
      this.$el.on('destroyed', this.onDestroy);

      this.props = $el.data();

      this.componentDidMount();
    }

    // Destroy a UI component
    UIComponent.prototype.onDestroy = function() {
      if (!this.isMounted())
        return;

      this.componentWillUnmount();

      // Remove any event handlers
      var $el = this.$el;
      this.$el = null;
      $el.off('click', this.onClick);
      $el.on('destroyed', this.onDestroy);

      this.componentDidUnmount();
    }

    // Return a default state for this component
    UIComponent.prototype.getInitialState = function() { }

    // Extend/merge my state and possibly re-render
    UIComponent.prototype.setState = function(state) {
      if (!this.isUpdating) {
        // Allow things to settle - no need to call more than once per execution
        this.isUpdating = setTimeout( this.onUpdate, 1 );
      }

      // Merge this into our state
      for (var key in state) {
        if (__hasProp.call(state, key))
          this.state[key] = state[key];
      }
    }

    // Replace my state and possibly re-render
    UIComponent.prototype.replaceState = function(state) {
      if (!this.isUpdating) {
        // Allow things to settle - no need to call more than once per execution
        this.isUpdating = setTimeout( this.onUpdate, 1 );
      }

      this.state = state || {};
    }

    // My state has been changed
    UIComponent.prototype.onUpdate = function(ev) {
      // Don't do anything if no longer mounted
      if (this.isMounted()) {
        this.render();
      }

      // I'm no longer updating
      delete this.isUpdating;
    }

    // Render into this element, given some state
    // There is no default rendering
    UIComponent.prototype.render = function() { }

    // Handle a click
    // There is no default click behavior
    UIComponent.prototype.onClick = function(ev) { }

    // Mount/unmount notifications
    UIComponent.prototype.componentWillMount = function() { }
    UIComponent.prototype.componentDidMount = function() { }
    UIComponent.prototype.componentWillUnmount = function() { }
    UIComponent.prototype.componentDidUnmount = function() { }
    UIComponent.prototype.isMounted = function() {
      return this.$el !== null;
    }

    return UIComponent;
  })();


  // class HeaderProgress extends UIComponent
  HeaderProgress = (function(_super) {
    __extends(HeaderProgress, _super);

    // Must have a constructor
    function HeaderProgress() {
      return HeaderProgress.__super__.constructor.apply(this, arguments);
    }

    HeaderProgress.prototype.componentDidMount = function() {
      // TODO: enable the fetchProgress call here when we've removed the pushed state
      this.fetchProgress();

      // Create tooltips for the free-play icons
      $('.level_free_play').qtip({
        content: {
          attr: 'title'
        },
        position: {
          my: 'top center',
          at: 'bottom center'
        }
      });
    }

    // Fetch the user's progress via an AJAX call
    // TODO: This should move to a store.
    HeaderProgress.prototype.fetchProgress = function() {
      var url = this.props.url || '/popup/progress';
      var _this = this;

      $.getJSON(url, {
        script_name: this.props.scriptName,
        stage_id: this.props.stageId,
        level_id: this.props.levelId
      })
      .done(function(data) {
        _this.replaceState(data);
      })
      .fail(function(xhr) {
        // TODO: error case?
      });
    }

    HeaderProgress.prototype.render = function() {
      var cl, el;
      var _this = this;
      var state = this.state || {};

      // Don't render unless we have the data attributes
      // TODO: REMOVE after _header.html.haml is converted
      if (!this.props.scriptName)
        return;

      // NOTE: All this DOM manipulation would be better done via a template - but we're in the process
      // of picking a template language vs JSX

      var $middle = _this.$el.find('.header_middle');
      $middle.children().remove();
      el = $('<div>').addClass('header_level').appendTo($middle);
      var $container = $('<div>').addClass('header_level_container').appendTo(el);

      // Title
      if (state.title) {
        $('<div>').addClass('header_text').text(state.title).appendTo($container);
      }

      // Progress: Render the array of levels
      var levels = state.levels || [];
      if (levels.length) {
        var els = $.map(levels, function(level, index) {
          cl = 'level_link ' + level.status;
          if (level.unplugged)
            cl += ' unplugged_level';
          var link = $('<a>').addClass(cl).attr('href', level.link).text(level.displayText);

          cl = level.assessment ? 'puzzle_outer_assessment' : 'puzzle_outer_level';
          if (index === state.currentLevelIndex)
            cl += ' puzzle_outer_current';
          if (index === levels.length - 1)
            cl += ' last';
          return $('<div>').addClass(cl).append(link);
        });

        $('<div>').addClass('progress_container').append(els).appendTo($container);
      }

      // Finished link
      if (state.finishLink) {
        el = $('<div>').addClass('header_finished_link');
        $('<a>').attr('href', state.finishLink.href).text(state.finishLink.text).appendTo(el);
        el.appendTo($container);
      }

      // Trophies
      if (state.trophies) {
        el = $('<span>').addClass('header_trophy_link');
        $('<div>').addClass('header_text').text('<%= I18n.t(:trophies) %>').appendTo(el);
        $('<div>').addClass('header_status_bar current_trophies').text(state.trophies.current).appendTo(el);
        $('<div>').addClass('header_text max_trophies').text(state.trophies.of + ' ' + state.trophies.max).appendTo(el);
        el.appendTo($container);
      }

      // Stage popup
      if (state.showStageLinks) {
        el = $('<span>').addClass('header_popup_link');

        if (state.popped) {
          $('<div>').addClass('header_popup_link_glyph').html("&#x25B2;").appendTo(el);
          $('<div>').addClass('header_popup_link_text').text('<%= I18n.t(:less) %>').appendTo(el);
        } else {
          $('<div>').addClass('header_popup_link_glyph').html("&#x25BC;").appendTo(el);
          $('<div>').addClass('header_popup_link_text').text('<%= I18n.t(:more) %>').appendTo(el);
        }
        el.appendTo($container);

        $('.freeplay_links').show();
      } else {
        $('.freeplay_links').hide();
      }

      // Popup stage navigation
      if (state.popped) {
        var header_popup = $('<div>').addClass('header_popup').appendTo($middle);

        el = $('<div>').addClass('header_popup_header').appendTo(header_popup);
        $('<span>').text('<%= I18n.t("nav.popup.progress") %>').appendTo(el);
        if (state.linesOfCodeText)
          $('<div>').addClass('header_text').css('float','right').text(state.linesOfCodeText).appendTo(el);

        el = $('<div>').addClass('header_popup_body').appendTo(header_popup);
        el.html(state.stageHtml || '<div class="loading"></div>');

        el = $('<div>').addClass('header_popup_footer').appendTo(header_popup);
        $('<div>').addClass('header_popup_close').text('<%= I18n.t("nav.popup.close") %>').appendTo(el);

        header_popup.show(); // TODO: Not needed after removing the display:none; in the CSS
      }

    }

    HeaderProgress.prototype.showPopup = function(show) {
      var _this = this;

      headerProgress.setState({
        popped: !!show
      });

      // Have we loaded the stage HTML already?  If not, load it now.
      if (this.state.stageHtml === undefined) {
        this.state.stageHtml = false;

        $.ajax({
          url: this.state.statsPath,
          data: {
            script_id: this.state.scriptId,
            script_level_id: this.state.scriptLevelId
          },
          success: function (result) {
            _this.setState({
              stageHtml: result
            })

            if (show == "trophies") {
              // TODO: Jump to trophies
            }
          }
        });
      } else if (show == "trophies") {
        // TODO: Jump to trophies
      }

      /* TODO:
        function jumpToTrophies() {
          window.scrollTo(0, +$('#trophies').offset().top);
        }
      */
    }

    HeaderProgress.prototype.onClick = function(ev) {
      var el;

      // Toggle more/less button
      el = $(ev.target).closest('.header_trophy_link');
      if (el.length) {
        this.showPopup("trophies");
        return;
      }

      // Toggle more/less button
      el = $(ev.target).closest('.header_popup_link');
      if (el.length) {
        this.showPopup(!this.state.popped);
        return;
      }

      // Close button
      el = $(ev.target).closest('.header_popup_close');
      if (el.length) {
        this.showPopup(false);
        return;
      }

      el = $(ev.target).closest('.header_popup');
      if (el.length) {
        ev.stopPropagation(); // Clicks inside the popup shouldn't close it
        return;
      }


      // TODO:
      // -- jump to the trophies if that was clicked
      // -- catch window clicks and close the popup
      // -- don't close the popup if clicking inside it

      /*
        function jumpToTrophies() {
          window.scrollTo(0, +$('#trophies').offset().top);
        }
      */

      // TODO: Default behaviors
      alert('header click');

    }

    return HeaderProgress;
  })(UIComponent);


  // For now, create a global.  Later, this should be in module.exports
  window.HeaderProgress = HeaderProgress;

}).call(this);
