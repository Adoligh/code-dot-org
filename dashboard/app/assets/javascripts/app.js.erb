// ****************
//  IMPORTANT NOTE
// ****************
//
// This file contains proof-of-concept code (though it's safe for production)
// - UIComponent is an example React implementation
// - UIStore is an example Flux implementation
// - UIRouter is a really simple router
//
// These classes (and the derived ones) look pretty 'bulky' as they are written today.
// If we begin using React, this file will shrink to less than half of its current size.
// With CoffeeScript it'll shrink at least another half.
// There's really not that much "logic" here, it's just boilerplate that can be eliminated!

// New private scope -- a lot of this is boilerplate for class structures, taken from coffeescript
(function() {
  var
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };


  // class UIComponent: this is a lightweight inheritable class modeled after React
  var UIComponent = (function() {

    function UIComponent($el, props) {
      this.onClick = __bind(this.onClick, this);
      this.onUpdate = __bind(this.onUpdate, this);
      this.onDestroy = __bind(this.onDestroy, this);

      this.$el = $el;
      this.$el.on('click touchstart', this.onClick);
      this.$el.on('destroyed', this.onDestroy);

      this.props = $.extend({}, $el.data(), props);
      this.isMounting = true;

      // Set the initial state
      this.replaceState( this.getInitialState() || {} );
    }

    // Destroy a UI component
    UIComponent.prototype.onDestroy = function() {
      // Don't do anything if already not mounted
      if (!this.isMounted())
        return;

      this.componentWillUnmount();

      // Remove any event handlers
      var $el = this.$el;
      this.$el = null;
      $el.off('click touchstart', this.onClick);
      $el.on('destroyed', this.onDestroy);

      this.componentDidUnmount();
    }

    // Return a default state for this component
    UIComponent.prototype.getInitialState = function() { }

    // Extend/merge my state and possibly re-render
    UIComponent.prototype.setState = function(state) {
      if (!this.isUpdating) {
        // Allow things to settle - no need to call more than once per execution
        this.isUpdating = setTimeout( this.onUpdate, 1 );
      }

      // Merge this into our state
      for (var key in state) {
        if (__hasProp.call(state, key))
          this.state[key] = state[key];
      }
    }

    // Replace my state and possibly re-render
    UIComponent.prototype.replaceState = function(state) {
      if (!this.isUpdating) {
        // Allow things to settle - no need to call more than once per execution
        this.isUpdating = setTimeout( this.onUpdate, 1 );
      }

      this.state = state || {};
    }

    // My state has been changed, and we've let all other processes yield, so we know
    // there are no more changes coming.  Time to update the DOM.
    UIComponent.prototype.onUpdate = function(ev) {
      // Don't do anything if no longer mounted
      if (!this.isMounted())
        return;

      this.isMounting ? this.componentWillMount() : this.componentWillUpdate();

      this.render();
      delete this.isUpdating;

      this.$el.addClass('ui-rendered');

      this.isMounting ? this.componentDidMount() : this.componentDidUpdate();
      delete this.isMounting;
    }

    // Render into this element, given some state
    // There is no default rendering
    UIComponent.prototype.render = function() { }

    // Handle a click
    // There is no default click behavior
    UIComponent.prototype.onClick = function(ev) { }

    // Mount/unmount notifications
    UIComponent.prototype.componentWillMount = function() { }
    UIComponent.prototype.componentDidMount = function() { }
    UIComponent.prototype.componentWillUnmount = function() { }
    UIComponent.prototype.componentDidUnmount = function() { }
    UIComponent.prototype.componentWillUpdate = function() { }
    UIComponent.prototype.componentDidUpdate = function() { }
    UIComponent.prototype.isMounted = function() {
      return this.$el !== null;
    }

    return UIComponent;
  })();





  // class UIRouter: this is an incredibly simple router with our routes baked into it.
  // This will be completely replaced when we choose a router.
  UIRouter = (function() {

    function UIRouter() { }

    UIRouter.prototype.route = function() {
      var re, parts, el,
        url = window.location.pathname;

      var headerStore = new HeaderStore();

      // Special handling for #blocklyApp, which could be on any route.
      el = $('#blocklyApp');
      if (el.length) {
        window.blocklyApp = new BlocklyApp( el, {
          headerStore: headerStore
        });
      }

      el = $('#reference_area');
      if (el.length) {
        window.blocklyApp = new ReferenceArea( el, {
          headerStore: headerStore
        });
      }


      // s/:script_id/level/:level_id
      // (only applies to the default scripts ID < 8)
      re = /\/s\/(\d+)\/(level|puzzle)\/(\d+)$/i;
      parts = url.match(re);
      if (parts) {
        window.headerProgress = new HeaderProgress( $('.header-wrapper'), {
          headerStore: headerStore
        });

        headerStore.load({
          script_id: parts[1],
          level_id: parts[3]
        });

        return;
      }

      // hoc|k8intro|editcode|2014|builder|flappy|jigsaw/:level
      re = /\/(\w+)\/(\d+)$/i;
      parts = url.match(re);
      if (parts) {
        var apps = {
          hoc: 'Hour of Code',
          k8intro: '20-hour',
          editcode: 'edit-code',
          '2014': 'events',
          flappy: 'flappy',
          jigsaw: 'jigsaw'
        };

        var app = apps[parts[1]];
        if (app) {
          window.headerProgress = new HeaderProgress( $('.header-wrapper'), {
            headerStore: headerStore
          });

          headerStore.load({
            script_name: app,
            level_id: parts[2]
          });

          return;
        }
      }

      // s/:script_name/stage/:stage_id/level/:level_id
      re = /\/s\/(.+)\/stage\/(\d+)\/puzzle\/(\d+)$/i;
      parts = url.match(re);
      if (parts) {
        window.headerProgress = new HeaderProgress( $('.header-wrapper'), {
          headerStore: headerStore
        });

        headerStore.load({
          script_name: parts[1],
          stage_id: parts[2],
          level_id: parts[3]
        });

        return;
      }

      // Unknown route
      return null;
    }


    return UIRouter;
  })();




  // class UIStore: this is a lightweight inheritable *ABSTRACT* class modeled after Flux
  // UIStore is "offline-aware", meaning that it will load assets in a different way when
  // it knows that there is no network connection.
  var UIStore = (function() {

    function UIStore() {
      this.save = __bind(this.save, this);
      this.onAjaxFailure = __bind(this.onAjaxFailure, this);

      this.value = null; // Empty store
      this.notificationCallbacks = [];
    }

    // Get the value of this store
    UIStore.prototype.value = function() { return this.value; }

    // When this store changes, notify via callback(data)
    UIStore.prototype.notify = function(callback) {
      this.notificationCallbacks.push(callback);
    }

    // Internal call to process any data that's being saved
    UIStore.prototype.process = function(data) { return data; }

    // Set the value of this store and notify the dependent
    UIStore.prototype.save = function(data) {
      this.value = this.process(data);

      // Note: Flux uses emitters...
      for (var i = 0; i < this.notificationCallbacks.length; i++)
        this.notificationCallbacks[i](this.value);
    }

    // Resolve a dynamic asset by combining the base asset filename + a serialized version of the args
    // MUST override this.  It's okay to use args and dataType to determine the URL.
    UIStore.prototype.resolveUrl = function(args, dataType) {
      throw new Error("This store has not specified its URL.");
    }

    // Resolve a static asset by combining the base asset filename + a serialized version of the args
    // MUST override this if you want to support offline access.
    // Example: return "/data/file_" + args.id + "." + dataType;
    UIStore.prototype.resolveFilename = function(args, dataType) {
      throw new Error("This store does not support offline mode.");
    }

    // Resolve the AJAX parameters for a dynamic request
    // Okay to override this to, for instance, move some of the args into the URL, etc.
    UIStore.prototype.resolve = function(args, dataType) {
      return {
        url: this.resolveUrl(args, dataType),
        data: args
      };
    }

    // What are the AJAX parameters for this callback?
    // If you override this, the override should be offline-aware.
    UIStore.prototype.resolveAjax = function(args, dataType) {
      var ajax;

      if (!this.offline)
        return this.resolve(args);

      // Offline case
      return {
        url: this.resolveFilename(args, dataType)
      };
    }

    UIStore.prototype.onAjaxFailure = function(xhr, status, message) {
      // TODO
    }

    // Load data into this store
    UIStore.prototype.$load = function(args, dataType, fnSave) {
      dataType = dataType || "json";

      // Set up the AJAX call to request the asset and then store the data, or raise an error.
      var ajax = this.resolveAjax(args, dataType);
      ajax.dataType = dataType;
      ajax.success = fnSave || this.save;
      ajax.error = this.onAjaxError;
      ajax.beforeSend = function(xhr) {
        xhr.setRequestHeader('X-CSRF-Token', $('meta[name="csrf-token"]').attr('content'))
      };

      return $.ajax(ajax);
    }

    // Load JSON data into this store.
    UIStore.prototype.load = function(args) {
      return this.$load(args, "json");
    }

    // Helper: Load XML and return it as a JSON structure
    UIStore.prototype.loadXML = function(args) {
      return this.$load(args, "xml");
    }

    // Helper: Load HTML into this store, as a string
    UIStore.prototype.loadHTML = function(args) {
      return this.$load(args, "html");
    }

    return UIStore;
  })();



  // class UIFrame
  var UIFrame = (function() {

    function UIFrame() {
      this.router = new UIRouter();
    }

    UIFrame.prototype.init = function() {
      this.router.route();
    }

    // Load the script at a given URL and return a promise that resolves when it has executed
    UIFrame.prototype.loadSource = function(url) {
      return function () {
        return $.ajax({
          url: url,
          dataType: "script",
          cache: true
        });
      }
    }

    // Loads the given app stylesheet.
    UIFrame.prototype.loadStyle = function(url) {
      $('<link>', {
        rel: 'stylesheet',
        type: 'text/css',
        href: url
      }).appendTo(document.body);
    }

    return UIFrame;
  })();


  // class ReferenceArea extends UIComponent
  var ReferenceArea = (function(_super) {
    __extends(ReferenceArea, _super);

    // Must have a constructor
    function ReferenceArea() {
      ReferenceArea.__super__.constructor.apply(this, arguments);

      return this;
    }

    ReferenceArea.prototype.render = function() {
      var el;

      var state = this.state || {};
      var level = state.level || {}

      this.$el.html('');  // Clear out the children
      this.$el.addClass('reference_area');

      // if (current_user.teacher? || current_user.admin?)
      if (level.solutionPath) {
        el = $('<div>').addClass('solution_link').appendTo(this.$el);

        $('<a>').attr('href', level.solutionPath).text('<%= I18n.t("reference_area.teacher") %>').appendTo(el);
      }

      if (level.relatedVideos) {
        $('<p>').addClass('help_title').text('<%= I18n.t("reference_area.title") %>').appendTo(this.$el);
        $('<p>').addClass('help_subtitle').text('<%= I18n.t("reference_area.subtitle") %>').appendTo(this.$el);

        for (var i = 0; i < level.relatedVideos.length; i++) {
          var video = level.relatedVideos[i];

          el = $('<a>', {
            data: video.data,  // Note this doesn't show as data- attributes, but does work.
            href: '#'
          }).addClass('video_link').appendTo(this.$el);
          var img = $('<img>', {
            id: 'thumbnail_' + video.youtube_code,
            src: video.thumbnail_url,
            width: 39*4.7
            // height: 50*4.7,
          }).addClass('video_thumbnail').appendTo(el);
          el.append( $('<div>').addClass('video_name').append( $('<span>').text(video.name) ) );

          if ((i % 2) == 1)
            $('<div>').addClass('clear').appendTo(this.$el);
        }

        $('<div>').addClass('clear').appendTo(this.$el);
      }
    }


    ReferenceArea.prototype.componentDidMount = function() {
      var _this = this;

      // When the headerStore gets data, update blockly
      this.props.headerStore.notify( function(data) {
        _this.setState({
          level: $.extend({}, data.level)
        });
      });

    }

    ReferenceArea.prototype.onClick = function(ev) {
      var el;

      // Click on a video
      el = $(ev.target).closest('.video_link');
      if (el.length) {
        ev.stopPropagation();

        showVideoDialog( $.extend({
          enable_fallback: true,
          autoplay: true
        }, el.data()) );

        return;
      }
    }


    return ReferenceArea;
  })(UIComponent);



  // class BlocklyApp extends UIComponent
  var BlocklyApp = (function(_super) {
    __extends(BlocklyApp, _super);

    // Must have a constructor
    function BlocklyApp() {
      BlocklyApp.__super__.constructor.apply(this, arguments);

      return this;
    }

    BlocklyApp.prototype.render = function() {
      var el;

      this.$el.html('');

      $('<div>').addClass('loading').appendTo(this.$el);

      el = $('<div>').addClass('slow_load').text('<%= I18n.t(:slow_loading) %>').appendTo(this.$el);

      $('<br>').appendTo(el);

      $('<a>', {
        href: 'javascript: location.reload();'
      }).text('<%= I18n.t(:try_reloading) %>').appendTo(el);
    }

    BlocklyApp.prototype.componentDidMount = function() {
      var _this = this;

      // Show the slow-loading warning if it takes more than 10 seconds to initialize
      var slow_load = _this.$el.find('.slow_load');
      setTimeout(function() {
        slow_load.show();
      }, 10000);

      // When the headerStore gets data, update blockly
      this.props.headerStore.notify( function(data) {

        // Set up the blockly options, starting from some default values
        var opts = $.extend({
          baseUrl: '/blockly/',
          containerId: _this.$el.attr('id')
        }, data.level);

        // Kick-start the blockly scripts
        _this.loadAssets(opts)
        .then(function() {
          _this.startBlockly(opts);
        });

      });

    }

    BlocklyApp.prototype.loadSource = function(name) {
      return Frame.loadSource(this.baseUrl + 'js/' + name + '.js');
    }

    BlocklyApp.prototype.loadStyle = function(name) {
      return Frame.loadStyle(this.baseUrl + 'css/' + name + '.css');
    }

    // Load the assets required for a certain level
    BlocklyApp.prototype.loadAssets = function(opts) {
      this.baseUrl = opts.baseUrl;

      this.loadStyle('common');
      this.loadStyle(opts.app);

      var promise;
      if (opts.droplet) {
        this.loadStyle('droplet/droplet.min');
        promise = this.loadSource('jsinterpreter/acorn_interpreter')()
          .then(this.loadSource('requirejs/require'))
          .then(this.loadSource('ace/ace'))
          .then(this.loadSource('ace/ext-language_tools'))
          .then(this.loadSource('droplet/droplet-full.min'));
      } else {
        promise = this.loadSource('blockly')()
          .then(this.loadSource(opts.locale + '/blockly_locale'));
      }
      return promise.then(this.loadSource('common' + opts.pretty))
        .then(this.loadSource(opts.locale + '/common_locale'))
        .then(this.loadSource(opts.locale + '/' + opts.app + '_locale'))
        .then(this.loadSource(opts.app + opts.pretty));
    }

    // Sets up default options and initializes blockly
    BlocklyApp.prototype.startBlockly = function(opts) {
      if (!this.isMounted())
        return;

      // Turn string values into functions for keys that begin with 'fn_' (JSON can't contain function definitions)
      // E.g. { fn_example: 'function () { return; }' } becomes { example: function () { return; } }
      (function fixUpFunctions(node) {
        if (typeof node !== 'object') return;

        for (var i in node) {
          if (/^fn_/.test(i)) {
            try {
              node[i.replace(/^fn_/, '')] = eval('(' + node[i] + ')');
            } catch (e) { }
          } else {
            fixUpFunctions(node[i]);
          }
        }
      })(opts.level);

      // Add all the default options for blockly.
      // Note that "this" in functions below is the blockly object, not this component.
      $.extend(opts, {
        Dialog: Dialog,
        cdoSounds: CDOSounds,
        position: { blockYCoordinateInterval: 25 },

        onInitialize: function() {
          // When called, "this" is bound to the options hash itself

          // TODO: Has moving this broken something?
          window.startTiming('Puzzle', this.scriptPath, '');

          // Hide callouts when the function editor is closed (otherwise they jump to the top left corner)
          $(window).on('function_editor_closed', function() {
            $('.cdo-qtips').qtip('hide');
          });

          this.createCallouts();
          if (window.wrapExistingClipPaths && window.handleClipPathChanges) {
            wrapExistingClipPaths();
            handleClipPathChanges();
          }

          $(document).trigger('appInitialized', this);
        },

        createCallouts: function() {
          $.fn.qtip.zindex = 500;
          this.callouts && this.callouts.every(function(callout) {
            var selector = callout.element_id; // jquery selector.
            if ($(selector).length === 0 && !callout.on) {
              return true;
            }

            var defaultConfig = {
              content: {
                text: callout.localized_text,
                title: {
                  button: $('<div class="tooltip-x-close"/>')
                }
              },
              style: {
                classes: "",
                tip: {
                  width: 20,
                  height: 20
                }
              },
              position: {
                my: "bottom left",
                at: "top right"
              },
              hide: {
                event: 'click mousedown touchstart'
              },
              show: false // don't show on mouseover
            };

            var customConfig = $.parseJSON(callout.qtip_config);
            var config = $.extend(true, {}, defaultConfig, customConfig);
            config.style.classes = config.style.classes.concat(" cdo-qtips");

            function reverseDirection(token) {
              if (/left/i.test(token)) {
                token = 'right';
              } else if (/right/i.test(token)) {
                token = 'left';
              }
              return token;
            }

            function reverseCallout(position) {
              position = position.split(/\s+/);
              var a = position[0];
              var b = position[1];
              return reverseDirection(a) + reverseDirection(b);
            }

            // Reverse callouts in RTL mode
            if (Blockly.RTL) {
              config.position.my = reverseCallout(config.position.my);
              config.position.at = reverseCallout(config.position.at);
              if (config.position.adjust) {
                config.position.adjust.x *= -1;
              }
            }

            if (callout.on) {
              window.addEventListener(callout.on, function() {
                if (!callout.seen && $(selector).length > 0) {
                  callout.seen = true;
                  $(selector).qtip(config).qtip('show');
                }
              });
            } else {
              $(selector).qtip(config).qtip('show');
            }

            return true;
          });
        },

        onAttempt: function(report) {
          report.fallbackResponse = this.report.fallback_response;
          report.callback = this.report.callback;

          // Track puzzle attempt event
          trackEvent('Puzzle', 'Attempt', this.scriptPath, report.pass ? 1 : 0);
          if (report.pass) {
            trackEvent('Puzzle', 'Success', this.scriptPath, report.attempt);
            window.stopTiming('Puzzle', this.scriptPath, '');
          }
          trackEvent('Activity', 'Lines of Code', this.scriptPath, report.lines);

          // Send the report
          sendReport(report);
        },
        onResetPressed: function() {
          cancelReport();
        },
        onContinue: function() {
          // TODO: Should not be using a global "lastServerResponse" here?
          if (lastServerResponse.videoInfo) {
            showVideoDialog(lastServerResponse.videoInfo);
          } else if (lastServerResponse.nextRedirect) {
            window.location.href = lastServerResponse.nextRedirect;
          }
        },
        backToPreviousLevel: function() {
          // TODO: Should not be using a global "lastServerResponse" here?
          if (lastServerResponse.previousLevelRedirect) {
            window.location.href = lastServerResponse.previousLevelRedirect;
          }
        },
        showInstructionsWrapper: function(showInstructions) {
          var hasInstructions = this.level.instructions || this.level.aniGifURL;
          if (!hasInstructions || this.share || this.level.skipInstructionsPopup) {
            return;
          }

          if (this.autoplayVideo) {
            showVideoDialog(this.autoplayVideo);
            $('.video-modal').on('hidden.bs.modal', function () {
              showInstructions();
            });
          } else {
            showInstructions();
          }
        }
      });

      // TODO: need a better way to bind this.  Consult with cpirich
      // Summary of the problem: onAttempt (and others) used global variables to get at the option
      // state like .scriptPath, as well as global functions like sendReport()
      // Ideally these would be available as local methods, but the current appMain & StudioApp code
      // does not offer any way to get at options.scriptPath when calling .onAttempt.
      // We could bind functions in onInitialize, but that's called *after* the functions have already
      // been copied out into the StudioApp.
      // The bigger question is: what *should* "this" be when calling parameters in the config block?
      // Getting to sendReport() is a whole other issue but maybe it's fine to leave as-is
      opts.onAttempt = __bind(opts.onAttempt, opts);
      opts.onContinue = __bind(opts.onContinue, opts);
      opts.backToPreviousLevel = __bind(opts.backToPreviousLevel, opts);
      opts.onResetPressed = __bind(opts.onResetPressed, opts);

      window[opts.app + 'Main'](opts);
    }

    return BlocklyApp;
  })(UIComponent);






  // Exports:
  window.UIStore = UIStore;
  window.UIComponent = UIComponent;
  window.UIRouter = UIRouter;
  window.UIFrame = UIFrame;
  window.BlocklyApp = BlocklyApp;

  window.Frame = new UIFrame();

  $(document).ready(function() {
    Frame.init();
  });

}).call(this);
